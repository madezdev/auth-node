/* eslint-disable camelcase */
import jwt from 'jsonwebtoken'
import logger from '../config/logger.config.js'
import config from '../config/index.js'
import { UserModel } from '../models/user.model.js'
import { UserRepository } from '../repositories/user.repository.js'
import { UserDTO } from '../dto/user.dto.js'
import { MailService } from '../services/mail.service.js'
import crypto from 'crypto'
import bcrypt from 'bcrypt'
import { CartModel } from '../models/cart.model.js'
import { PASSWORD_CONFIG, JWT_CONFIG, COOKIE_CONFIG } from '../config/security.config.js'
import { promisify } from 'util'

// Crear un nuevo administrador
export const createAdmin = async (req, res) => {
  try {
    const { first_name, last_name, email, age, password } = req.body

    logger.debug(`Intento de creación de admin: ${email}`)

    // Verificar si el usuario ya existe
    const existingUser = await UserModel.findOne({ email })
    if (existingUser) {
      return res.status(400).json({ status: 'error', message: 'Email already in use' })
    }

    // Crear un nuevo carrito para el usuario
    const newCart = await CartModel.create({})

    // Crear nuevo usuario administrador con referencia al carrito
    const newUser = await UserModel.create({
      first_name,
      last_name,
      email,
      age,
      password,
      cart: newCart._id,
      role: 'admin' // Set role to admin
    })

    // Generate JWT token
    const token = jwt.sign(
      { id: newUser._id, email: newUser.email, role: newUser.role },
      config.SECRET,
      { expiresIn: '24h' }
    )

    // Set token as HTTP-only cookie
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production', // Only send cookie over HTTPS in production
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    })

    logger.info(`Admin creado exitosamente: ${email} (ID: ${newUser._id})`)
    return res.status(201).json({
      status: 'success',
      message: 'Admin user created successfully',
      token // Still include token in response for API clients
    })
  } catch (error) {
    logger.error(`Error al crear admin: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred during admin creation',
      error: error.message
    })
  }
}

// Registrar un nuevo usuario
export const register = async (req, res) => {
  try {
    const { first_name, last_name, email, age, password } = req.body

    logger.debug(`Intento de registro: ${email}`)

    // Verificar si el usuario ya existe
    const existingUser = await UserModel.findOne({ email })
    if (existingUser) {
      return res.status(400).json({ status: 'error', message: 'Email already in use' })
    }

    // Crear un nuevo carrito para el usuario
    const newCart = await CartModel.create({})

    // Crear nuevo usuario con referencia al carrito
    const newUser = await UserModel.create({
      first_name,
      last_name,
      email,
      age,
      password,
      cart: newCart._id
    })

    // Generate JWT token
    const token = jwt.sign(
      { id: newUser._id, email: newUser.email, role: newUser.role },
      config.SECRET,
      { expiresIn: '24h' }
    )

    // Set token as HTTP-only cookie
    res.cookie('token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production', // Only send cookie over HTTPS in production
      sameSite: 'strict',
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    })

    logger.info(`Usuario registrado exitosamente: ${email} (ID: ${newUser._id})`)
    return res.status(201).json({
      status: 'success',
      message: 'User registered successfully',
      token // Still include token in response for API clients
    })
  } catch (error) {
    logger.error(`Error en registro: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred during registration',
      error: error.message
    })
  }
}

// Login usuario
export const login = async (req, res) => {
  try {
    const { email, password } = req.body
    const clientIp = req.ip

    logger.debug(`Intento de login: ${email} desde IP: ${clientIp}`)

    // Buscar usuario por email
    const user = await UserModel.findOne({ email })
    if (!user) {
      logger.warn(`Intento de login con email no registrado: ${email} desde IP: ${clientIp}`)
      // Simular el tiempo que tomaría verificar una contraseña para evitar timing attacks
      await promisify(setTimeout)(100)
      return res.status(401).json({ status: 'error', message: 'Invalid credentials' })
    }

    // Verificar si la cuenta está bloqueada
    if (user.accountLocked && user.accountLockedUntil > new Date()) {
      const remainingTimeMs = user.accountLockedUntil.getTime() - new Date().getTime()
      const remainingMinutes = Math.ceil(remainingTimeMs / 60000)
      logger.warn(`Intento de acceso a cuenta bloqueada: ${email} desde IP: ${clientIp}`)
      return res.status(403).json({
        status: 'error',
        message: `Account is temporarily locked. Please try again in ${remainingMinutes} minutes or reset your password.`
      })
    }

    // Actualizar timestamp del último intento de login
    user.lastLoginAttempt = new Date()
    user.lastLoginIp = clientIp

    // Validar contraseña
    const isPasswordValid = user.isValidPassword(password)
    if (!isPasswordValid) {
      // Incrementar contador de intentos fallidos
      user.failedLoginAttempts += 1
      logger.warn(`Intento de login fallido #${user.failedLoginAttempts} para: ${email} desde IP: ${clientIp}`)
      
      // Verificar si debemos bloquear la cuenta (5 intentos fallidos)
      if (user.failedLoginAttempts >= 5) {
        // Bloquear cuenta por 30 minutos
        const lockDuration = 30 * 60 * 1000 // 30 minutos en milisegundos
        user.accountLocked = true
        user.accountLockedUntil = new Date(Date.now() + lockDuration)
        
        await user.save()
        
        logger.warn(`Cuenta bloqueada por exceso de intentos: ${email} desde IP: ${clientIp}`)
        return res.status(403).json({
          status: 'error',
          message: 'Too many failed login attempts. Account locked for 30 minutes.'
        })
      }
      
      await user.save()
      return res.status(401).json({ status: 'error', message: 'Invalid credentials' })
    }

    // Verificar si el usuario tiene perfil completo y actualizar role si es necesario
    const userIsCompleted = user.first_name && user.last_name && user.age
    const addressIsCompleted = user.address && user.address.street && user.address.city && 
                              user.address.state && user.address.zipCode
    
    if (user.role === 'guest' && userIsCompleted && addressIsCompleted) {
      user.role = 'user'
      logger.info(`Usuario promovido a 'user': ${email} - perfil completado`)
    }

    // Credenciales válidas - resetear contador de intentos fallidos
    user.failedLoginAttempts = 0
    user.accountLocked = false
    user.accountLockedUntil = null
    await user.save()
    
    logger.debug(`Credenciales válidas para: ${email} desde IP: ${clientIp}`)

    // Generar access token (corta duración)
    const accessToken = jwt.sign(
      { id: user._id, email: user.email, role: user.role },
      config.SECRET,
      { expiresIn: JWT_CONFIG.EXPIRES_IN, algorithm: JWT_CONFIG.ALGORITHM }
    )
    
    // Generar refresh token (larga duración)
    const refreshToken = jwt.sign(
      { id: user._id },
      config.REFRESH_SECRET || config.SECRET + '_refresh',
      { expiresIn: '7d', algorithm: JWT_CONFIG.ALGORITHM }
    )

    // Set access token as HTTP-only cookie
    res.cookie(JWT_CONFIG.COOKIE_NAME, accessToken, {
      httpOnly: COOKIE_CONFIG.HTTP_ONLY,
      secure: COOKIE_CONFIG.SECURE,
      sameSite: COOKIE_CONFIG.SAME_SITE,
      maxAge: COOKIE_CONFIG.MAX_AGE
    })
    
    // Set refresh token as HTTP-only cookie with longer expiration
    res.cookie('refresh_token', refreshToken, {
      httpOnly: COOKIE_CONFIG.HTTP_ONLY,
      secure: COOKIE_CONFIG.SECURE,
      sameSite: COOKIE_CONFIG.SAME_SITE,
      maxAge: 7 * 24 * 60 * 60 * 1000 // 7 días
    })

    logger.info(`Login exitoso: ${email} (ID: ${user._id}, Role: ${user.role}, IP: ${clientIp}`)
    return res.status(200).json({
      status: 'success',
      message: 'Login successful',
      token: accessToken // Enviar solo access token al cliente
    })
  } catch (error) {
    logger.error(`Error en login: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred during login',
      error: error.message
    })
  }
}

// Logout usuario
export const logout = async (req, res) => {
  try {
    // Eliminar cookies de sesión
    res.clearCookie('token')
    res.clearCookie('refresh_token')
    
    logger.info(`Logout exitoso para usuario: ${req.user ? req.user.email : 'desconocido'}`)
    return res.status(200).json({
      status: 'success',
      message: 'Logout successful'
    })
  } catch (error) {
    logger.error(`Error en logout: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred during logout'
    })
  }
}

// Obtener usuario actual
export const getCurrentUser = async (req, res) => {
  try {
    const userId = req.user.id
    
    const userRepository = new UserRepository()
    const user = await userRepository.getById(userId)
    
    if (!user) {
      logger.warn(`Usuario no encontrado para ID: ${userId}`)
      return res.status(404).json({
        status: 'error',
        message: 'User not found'
      })
    }

    // Verificar si el usuario tiene perfil completo y actualizar role si es necesario
    const userIsCompleted = user.first_name && user.last_name && user.age
    const addressIsCompleted = user.address && user.address.street && user.address.city && 
                              user.address.state && user.address.zipCode
    
    if (user.role === 'guest' && userIsCompleted && addressIsCompleted) {
      user.role = 'user'
      await user.save()
      logger.info(`Usuario promovido a 'user': ${user.email} - perfil completado`)
    }
    
    const userDTO = new UserDTO(user)
    
    logger.info(`Información de usuario obtenida para: ${user.email}`)
    return res.status(200).json({
      status: 'success',
      user: userDTO
    })
  } catch (error) {
    logger.error(`Error al obtener usuario actual: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred while getting current user',
      error: error.message
    })
  }
}

// Request a password reset email
export const requestPasswordReset = async (req, res) => {
  try {
    const { email } = req.body
    
    if (!email) {
      return res.status(400).json({
        status: 'error',
        message: 'Email is required'
      })
    }
    
    logger.debug(`Solicitud de reset de password para: ${email}`)
    
    // Find user by email
    const user = await UserModel.findOne({ email })
    
    // Si el usuario no existe, aun así devolvemos mensaje exitoso por seguridad
    // para evitar enumeración de usuarios
    if (!user) {
      logger.warn(`Intento de reset de password para email no registrado: ${email}`)
      return res.status(200).json({
        status: 'success',
        message: 'If that email address is in our database, we will send you an email to reset your password'
      })
    }
    
    // Generar token único para reset de contraseña
    const resetToken = crypto.randomBytes(32).toString('hex')
    
    // Establecer tiempo de expiración (1 hora)
    const expireDate = new Date()
    expireDate.setHours(expireDate.getHours() + 1)
    
    // Guardar token en el usuario
    user.resetPasswordToken = resetToken
    user.resetPasswordExpires = expireDate
    await user.save()
    
    // Enviar correo con enlace de reset
    const resetUrl = `${process.env.CLIENT_URL || 'http://localhost:3000'}/reset-password/${resetToken}`
    
    try {
      const mailService = new MailService()
      await mailService.sendPasswordResetEmail({
        to: user.email,
        subject: 'Password Reset Request',
        resetUrl
      })
      
      logger.info(`Email de reset de password enviado a: ${user.email}`)
    } catch (mailError) {
      logger.error(`Error al enviar email de reset: ${mailError.message}`, { stack: mailError.stack })
      
      // Revertir cambios si falla el envío
      user.resetPasswordToken = undefined
      user.resetPasswordExpires = undefined
      await user.save()
      
      return res.status(500).json({
        status: 'error',
        message: 'Error sending password reset email'
      })
    }
    
    return res.status(200).json({
      status: 'success',
      message: 'If that email address is in our database, we will send you an email to reset your password'
    })
  } catch (error) {
    logger.error(`Error en solicitud de reset de password: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred during password reset request',
      error: error.message
    })
  }
}

/**
 * Verify password reset token
 */
export const verifyResetToken = async (req, res) => {
  try {
    const { token } = req.params
    
    if (!token) {
      return res.status(400).json({
        status: 'error',
        message: 'Reset token is required'
      })
    }
    
    logger.debug(`Verifying reset token: ${token}`)
    
    // Find user by reset token
    const userRepository = new UserRepository()
    const user = await userRepository.findByResetToken(token)
    
    if (!user) {
      logger.warn(`Invalid or expired reset token: ${token}`)
      return res.status(400).json({
        status: 'error',
        message: 'Password reset token is invalid or has expired'
      })
    }
    
    logger.info(`Valid reset token for user: ${user.email}`)
    return res.status(200).json({
      status: 'success',
      message: 'Token is valid',
      email: user.email
    })
  } catch (error) {
    logger.error(`Error verifying reset token: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred while verifying reset token',
      error: error.message
    })
  }
}

/**
 * Reset password with token
 */
export const resetPassword = async (req, res) => {
  try {
    const { token } = req.params
    const { password } = req.body
    
    if (!token || !password) {
      return res.status(400).json({
        status: 'error',
        message: 'Token and new password are required'
      })
    }
    
    logger.debug(`Resetting password with token: ${token}`)
    
    // Find user by reset token
    const userRepository = new UserRepository()
    const user = await userRepository.findByResetToken(token)
    
    if (!user) {
      logger.warn(`Invalid or expired reset token during password reset: ${token}`)
      return res.status(400).json({
        status: 'error',
        message: 'Password reset token is invalid or has expired'
      })
    }
    
    // Check if the new password is the same as the current one
    const isSamePassword = user.isValidPassword(password)
    if (isSamePassword) {
      logger.warn(`User ${user.email} attempted to reset password to the current password`)
      return res.status(400).json({
        status: 'error',
        message: 'New password cannot be the same as the current one'
      })
    }
    
    // Check if password was used previously
    const wasUsedBefore = user.previousPasswords && 
      user.previousPasswords.some(prevPassword => {
        return bcrypt.compareSync(password, prevPassword)
      })
    
    if (wasUsedBefore) {
      logger.warn(`User ${user.email} attempted to reset password to a previously used password`)
      return res.status(400).json({
        status: 'error',
        message: 'New password cannot be the same as any of your previous passwords'
      })
    }
    
    // Store the current password in previousPasswords array before updating
    if (!user.previousPasswords) {
      user.previousPasswords = []
    }
    user.previousPasswords.push(user.password)
    
    // Limit the number of stored previous passwords (e.g., keep only the last 5)
    if (user.previousPasswords.length > 5) {
      user.previousPasswords = user.previousPasswords.slice(-5)
    }
    
    // Update user password
    user.password = password
    
    // Clear the reset token
    user.resetPasswordToken = undefined
    user.resetPasswordExpires = undefined
    
    // Desbloquear cuenta si estaba bloqueada
    user.accountLocked = false
    user.accountLockedUntil = null
    user.failedLoginAttempts = 0
    
    await user.save()
    
    logger.info(`Password successfully reset for user: ${user.email}`)
    return res.status(200).json({
      status: 'success',
      message: 'Password has been successfully reset'
    })
  } catch (error) {
    logger.error(`Error resetting password: ${error.message}`, { stack: error.stack })
    return res.status(500).json({
      status: 'error',
      message: 'An error occurred while resetting password',
      error: error.message
    })
  }
}
